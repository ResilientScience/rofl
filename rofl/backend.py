#! /usr/bin/env python
# ______________________________________________________________________
"""Module rofl.backend

Defines the back-end (code generator) for the ROFL equation language.
"""
# ______________________________________________________________________
# Module imports

import types
import itertools
import os
import imp
import marshal
import struct

import frontend
import rofl_ast

import sympy.printing

# ______________________________________________________________________
# Module data

DEFAULT_MODULE_NAME = '<rofl_codegen_module>'

ROFL_PRELUDE = '''"Automatically generated by ROFL compiler."

from rofl.utils import *

'''

# ______________________________________________________________________
# Pretty printing class definition

class CodegenStrPrinter (sympy.printing.StrPrinter):
    printmethod = 'my_codegen'

    def _print_Rational (self, expr):
        return '(%r.)' % (expr,)

    def _print_ImaginaryUnit (self, expr):
        return '(1j)'

# ______________________________________________________________________
# Function definitions

def get_lambdas (expr):
    ret_val = []
    if isinstance(expr, rofl_ast.Lambda):
        ret_val.extend(get_lambdas(expr.args[-1]))
        ret_val.append(expr)
    else:
        for subexpr in expr.args:
            ret_val.extend(get_lambdas(subexpr))
    return ret_val

# ______________________________________________________________________

def get_symbols (lhs, crnt_names):
    ret_val = set()
    if lhs.is_Symbol and lhs not in crnt_names:
        ret_val.add(lhs)
    elif isinstance(lhs, rofl_ast.Tuple):
        # This supports nested tuples, though I'm not sure the Tuple
        # lhs => Nth rhs transformation does:
        for sublhs in lhs.args:
            ret_val.update(get_symbols(sublhs, crnt_names))
    return ret_val

# ______________________________________________________________________

def get_free_vars (expr, crnt_names = None):
    ret_val = set()
    if crnt_names is None:
        crnt_names = set()
    else:
        crnt_names = set(crnt_names)
    if isinstance(expr, rofl_ast.Lambda):
        crnt_names.update(expr.args[0])
        ret_val.update(get_free_vars(expr.args[-1], crnt_names))
    elif isinstance(expr, rofl_ast.Let):
        subexprs = expr.args
        while len(subexprs) > 1:
            # This order is important.  We should NOT permit recursive
            # let's, so we do not extend the binding environment until
            # we've already looked at the RHS.
            ret_val.update(get_free_vars(subexprs[1], crnt_names))
            crnt_names.update(get_symbols(subexprs[0], crnt_names))
            subexprs = subexprs[2:]
        ret_val.update(get_free_vars(subexprs[0], crnt_names))
    elif isinstance(expr, rofl_ast.ListComp):
        # This gets a bit tricky...what we really want to do is split
        # the list at each CompFor, reverse the split list, then
        # process each sub-list linearly.
        comp_for_lists = []
        crnt_comp_for_list = []
        for subexpr in expr.args:
            if isinstance(subexpr, rofl_ast.CompFor):
                comp_for_lists.append(crnt_comp_for_list)
                crnt_comp_for_list = [subexpr]
            else:
                crnt_comp_for_list.append(subexpr)
        comp_for_lists.append(crnt_comp_for_list)
        comp_for_lists.reverse()
        for comp_for_list in comp_for_lists:
            if len(comp_for_list) > 0:
                if isinstance(comp_for_list[0], rofl_ast.CompFor):
                    comp_for = comp_for_list[0]
                    crnt_names.update(get_symbols(comp_for.args[0], crnt_names))
                    ret_val.update(get_free_vars(comp_for.args[1], crnt_names))
                    comp_for_list = comp_for_list[1:]
                for subexpr in comp_for_list:
                    ret_val.update(get_free_vars(subexpr, crnt_names))
    else:
        if (expr.is_Symbol and (expr not in crnt_names)):
            name = expr.name
            if len(name) > 0 and (not name.startswith(('$', '..', '(', '['))):
                ret_val.add(expr)
        # Note that this implementation ignores the names in 'native'
        # SymPy function application.  For example, App(f, x) will see
        # the f symbol, while f(x) will not.
        for arg in expr.args:
            ret_val.update(get_free_vars(arg, crnt_names))
    return ret_val

# ______________________________________________________________________

def replacement_lambda (sym_lambda, subs_env, crnt_names):
    args = list(get_free_vars(sym_lambda, crnt_names))
    args.extend(list(sym_lambda.args[0]))
    lexpr = sym_lambda.args[-1].subs(subs_env)
    return rofl_ast.Lambda(tuple(args), lexpr)

# ______________________________________________________________________

def lambda_lift (expr, **kws):
    """
    Thoughts/notes/etc.:

    For this to work currently, we'll have to already desugar and reduce any
    surface Let's.  (?) Is that true?
    """
    lambdas = get_lambdas(expr)
    let_args = []
    subs_env = {}
    lamb_names = {}
    crnt_names = set()
    for index, lamb in enumerate(lambdas):
        sub_exp = lifted_sym= sympy.Symbol('__func_%d' % index)
        lamb_names[lamb] = lifted_sym
        free_vars = list(get_free_vars(lamb, lamb_names.itervalues()))
        if len(free_vars) > 0:
            # Note that if Sympy did not support partial application
            # of a Lambda term, we'd have to create a closure here.
            # PartialApp is a subclass of App that generates different
            # Python code.
            sub_exp = rofl_ast.PartialApp(lifted_sym, *free_vars)
        subs_env[lamb] = sub_exp
    for lamb in lambdas:
        let_args.append(lamb_names[lamb])
        let_args.append(replacement_lambda(lamb, subs_env, crnt_names))
    let_args.append(expr.subs(subs_env))
    return rofl_ast.Let(*let_args)

# ______________________________________________________________________

def rec_lambdify (sympy_lambda, env = None):
    if __DEBUG__:
        print "rec_lambdify:", sympy_lambda
    assert isinstance(sympy_lambda, sympy.Lambda)
    if env is None:
        env = {}
    def _rec_lambdify (sympy_lambda):
        return rec_lambdify(sympy_lambda, env)
    if "Lambda" not in env:
        env["Lambda"] = _rec_lambdify
    sympy_lambda_params = sympy_lambda.args[0]
    if len(sympy_lambda_params) == 1:
        lambdify_params = sympy_lambda_params[0]
    else:
        lambdify_params = sympy_lambda_params
    return sympy.lambdify(lambdify_params, sympy_lambda.args[1], env)

# ______________________________________________________________________

def find_names (syntax_tree_tup):
    names = set()
    worklist = [syntax_tree_tup]
    while len(worklist) > 0:
        crnt = worklist.pop(0)
        if isinstance(crnt, tuple):
            if crnt[0] == token.NAME:
                names.add(crnt[1])
            elif crnt[0] > token.N_TOKENS:
                worklist += list(crnt[1:])
    return names

# ______________________________________________________________________

def codegen_expr (expr):
    return CodegenStrPrinter().doprint(expr)

# ______________________________________________________________________

value_symbols = sympy.numbered_symbols('__val_')

def normalize (expr):
    # if this is a let binding, desugar it...
    if hasattr(expr, 'desugar'):
        expr = expr.desugar()
    # Now do common subexpression elimination
    cse_bindings, cse_exprs = sympy.cse(expr, value_symbols)
    let_args = []
    for binding in cse_bindings:
        let_args.extend(binding)
    # Sanity check to ensure we came out of cse with the same number
    # of expressions as we sent in...
    assert len(cse_exprs) == 1
    let_args.append(cse_exprs[0])
    return rofl_ast.Let(*let_args)

# ______________________________________________________________________

def codegen_lambda (name, expr):
    assert isinstance(expr, rofl_ast.Lambda)
    prelude = "def %s (%s):\n" % (str(name),
                                  ", ".join((str(sym)
                                             for sym in expr.args[0])))
    body = ""
    rexpr = normalize(expr.args[-1])
    if isinstance(rexpr, rofl_ast.Let):
        bindings = list(rexpr.args[:-1])
        while bindings:
            assert isinstance(bindings[0], sympy.Symbol)
            body += "    %s = %s\n" % (str(bindings[0]),
                                       codegen_expr(bindings[1]))
            del bindings[:2]
        rexpr = rexpr.args[-1]
    postlude = "    return %s\n" % (codegen_expr(rexpr))
    return "%s%s%s" % (prelude, body, postlude)

# ______________________________________________________________________

def codegen_ll_let (ll_obj, prelude = None, **kws):
    assert isinstance(ll_obj, rofl_ast.Let)
    if prelude is None:
        prelude = ROFL_PRELUDE
    definitions = list(ll_obj.args[:-1])
    assert len(definitions) % 2 == 0
    body = ""
    while definitions:
        body += codegen_lambda(definitions[0], definitions[1])
        body += "\n"
        del definitions[:2]
    postlude = "\ntoplevel = %s\n" % (codegen_expr(ll_obj.args[-1].desugar()))
    module_src = ''.join((prelude, body, postlude))
    if kws.get('include_text', False):
        ret_val = '%s\n\nMODULE_SRC = %r\n' % (module_src, module_src)
    else:
        ret_val = module_src
    return ret_val

# ______________________________________________________________________

def codegen_out_src (toplevel_code, module_name = None, **kws):
    ll_obj = lambda_lift(toplevel_code, **kws)
    out_src = codegen_ll_let(ll_obj, **kws)
    return out_src

# ______________________________________________________________________

def codegen_module_src (toplevel_bindings, module_name = None, **kws):
    if module_name is None:
        module_name = DEFAULT_MODULE_NAME
    let_args = toplevel_bindings[:]
    let_args.append([toplevel_bindings[-1][0]])
    binding_let = rofl_ast.Let(*itertools.chain(*let_args))
    ret_val = codegen_out_src(binding_let, **kws)
    return ret_val

# ______________________________________________________________________

def codegen_module_co (toplevel_bindings, module_name = None, **kws):
    toplevel_code_src = codegen_module_src(toplevel_bindings, module_name,
                                           **kws)
    ret_val = compile(toplevel_code_src, module_name + '.rofl', 'exec')
    return ret_val

# ______________________________________________________________________

def codegen_module (toplevel_bindings, module_name = None, **kws):
    if module_name is None:
        module_name = DEFAULT_MODULE_NAME
    ret_val = types.ModuleType(module_name)
    code_obj = codegen_module_co(toplevel_bindings, module_name, **kws)
    exec code_obj in ret_val.__dict__
    return ret_val

# ______________________________________________________________________

def output_module_file (name, code_obj, **kws):
    mtime = 0
    if 'filename' in kws:
        mtime = os.path.getmtime(kws['filename'])
    with open(name, 'wb') as file_obj:
        file_obj.write(imp.get_magic())
        file_obj.write(struct.pack('<i', mtime)) # Modified time.
        file_obj.write(marshal.dumps(code_obj))

# ______________________________________________________________________
# Main (self-test) routine

def main (*args):
    import getopt
    console_out = False
    py_text = False
    opts, args = getopt.getopt(args, 'cp')
    for opt_flag, opt_val in opts:
        if opt_flag == '-c':
            py_text = True
            console_out = True
        elif opt_flag == '-p':
            py_text = True
    if len(args) > 0:
        for arg in args:
            base_path, _ = os.path.splitext(arg)
            base_name = os.path.basename(base_path)
            with open(arg) as input_file:
                bindings = frontend.parse_string(input_file.read())
            if py_text:
                out_module_src = codegen_module_src(bindings, base_name)
                if console_out:
                    print(out_module_src)
                else:
                    with open(base_path + '.py', 'w') as file_obj:
                        file_obj.write(out_module_src)
            else:
                out_module_co = codegen_module_co(bindings, base_name)
                output_module_file(base_path + '.pyc', out_module_co,
                                   filename = arg)
    else:
        bindings = frontend.parse_string(frontend.TEST_SRC)
        if py_text:
            out_module_src = codegen_module_src(bindings, 'backend_test')
            if console_out:
                print(out_module_src)
            else:
                with open('backend_test.py', 'w') as file_obj:
                    file_obj.write(out_module_src)
        else:
            out_module_co = codegen_module_co(bindings, 'backend_test')
            output_module_file('backend_test.pyc', out_module_co)

# ______________________________________________________________________

if __name__ == "__main__":
    import sys
    main(*sys.argv[1:])

# ______________________________________________________________________
# End of backend.py
